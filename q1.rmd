---
title: "Q1"
author: "Olta Recica"
date: "2026-02-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries}
library(sf)
library(tidyverse)
library(rnaturalearth)
library(rnaturalearthdata)
```

In this section, we load the packages needed for the analysis.
We use sf to work with spatial data, tidyverse for data manipulation and plotting, and the rnaturalearth packages to access Natural Earth spatial datasets.

```{r countries}
countries <- ne_countries(
  scale = "medium",
  returnclass = "sf"
)
```

We load the world country boundaries from Natural Earth using the `ne_countries` function.  
This dataset provides polygon geometries for countries and will be used as the base map for the analysis.

```{r populated_places}
pop_places <- ne_download(
  scale = "medium",
  type = "populated_places",
  category = "cultural",
  returnclass = "sf"
)
```

We load the populated places dataset from Natural Earth.
This dataset contains point locations of cities and settlements along with population information, which will be used to measure population distribution.

```{r airports}
airports <- ne_download(
  scale = 10,
  type = "airports",
  category = "cultural",
  returnclass = "sf"
)
```

We load the airports dataset from Natural Earth.  
This dataset contains point locations of major airports and will be used to compute distances between populated places and transportation infrastructure.

```{r projection}
countries <- st_transform(countries, 3857)
pop_places <- st_transform(pop_places, 3857)
airports <- st_transform(airports, 3857)
```

We transform all spatial datasets to the same projected coordinate reference system.  
Using a projected CRS allows distances to be calculated correctly and ensures consistency across all spatial operations.

## Clean populated places
```{r}
pop_places_clean <- pop_places %>%
  select(
    place_name = NAME,
    country_name = ADM0NAME,
    population = POP_MAX,
    geometry
  ) %>%
  filter(!is.na(population))
```

We clean the populated places data by keeping only the relevant variables.  
We also remove observations with missing population values so that the analysis is based only on valid population data.

## Spatial join: populated places -> countries
```{r}
pop_places_country <- st_join(
  pop_places_clean,
  countries,
  join = st_within
)
```

We spatially join populated places to country polygons.  
This assigns each populated place to the country it falls within, which allows population to be aggregated at the country level.

## Aggregate population at country level
```{r}
country_population <- pop_places_country %>%
  st_drop_geometry() %>%
  group_by(admin) %>%
  summarise(
    total_population = sum(population, na.rm = TRUE),
    n_places = n()
  )
```

We aggregate the populated places data at the country level.  
Total population is calculated by summing the population of all places within each country, and we also count how many populated places are included per country

## Join results back to country polygons
```{r}
countries_pop <- countries %>%
  left_join(country_population, by = "admin")
```

We join the country-level population totals back to the country polygons.  
This allows population information to be linked with spatial boundaries for mapping and further analysis.

```{r}
countries_pop %>%
  st_drop_geometry() %>%
  arrange(desc(total_population)) %>%
  select(admin, total_population, n_places) %>%
  head(10)
```

We display the countries with the highest total population.  
This provides a quick check of the aggregated population values before moving on to visualisation.

## 1 Map of population by country
```{r}
countries_pop_plot <- st_transform(countries_pop, 4326)
```

We transform the country-level dataset back to a geographic coordinate system. This step is done to prepare the data for mapping and visualisation.

```{r}
countries_pop_plot %>%
  filter(admin != "Antarctica") %>%
  ggplot() +
  geom_sf(aes(fill = total_population), linewidth = 0.1) +
  scale_fill_viridis_c(
    trans = "log10",
    na.value = "grey90"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank()
  ) +
  labs(
    title = "Country-level population from populated places",
    fill = "Population (log scale)"
  )
```

We create a world map showing total population by country.  
Countries are coloured by total population using a logarithmic scale to make differences across countries easier to see.

## 2 Histogram of country population by continent
```{r}
pop_by_continent <- countries_pop %>%
  st_drop_geometry() %>%
  filter(!is.na(total_population), !is.na(continent))
```

We prepare the country-level population data for comparison across continents.  
Countries with missing population or continent information are removed before creating continent-level summaries and plots.

```{r}
pop_by_continent <- countries_pop %>%
  st_drop_geometry() %>%
  filter(
    !is.na(total_population),
    !is.na(continent),
    !continent %in% c("Antarctica", "Seven seas (open ocean)")
  )

ggplot(pop_by_continent, aes(x = total_population)) +
  geom_histogram(bins = 20, fill = "steelblue", color = "white") +
  scale_x_log10() +
  facet_wrap(~ continent, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "Distribution of country-level population by continent",
    x = "Total population (log scale)",
    y = "Number of countries"
  )
theme(
  panel.grid = element_blank()
)

```

We plot a histogram of country-level population grouped by continent.Using a logarithmic scale helps visualise differences in population size across countries, while faceting allows comparison between continents.

## 3 Histogram of country-level average distance to airports by continent
```{r}
dist_matrix <- st_distance(pop_places_clean, airports)

pop_places_dist <- pop_places_clean %>%
  mutate(
    min_dist_airport_km = apply(dist_matrix, 1, min) / 1000
  )

pop_places_dist_country <- st_join(
  pop_places_dist,
  countries,
  join = st_within
)

country_dist <- pop_places_dist_country %>%
  st_drop_geometry() %>%
  group_by(admin, continent) %>%
  summarise(
    avg_dist_airport_km = mean(min_dist_airport_km, na.rm = TRUE),
    .groups = "drop"
  )

countries_final <- countries_pop %>%
  left_join(country_dist, by = c("admin", "continent"))
```

We compute the distance from each populated place to the nearest airport using spatial distance calculations.  
Distances are converted to kilometres and then averaged at the country level.  
This produces a country-level measure of average distance to airports, which is later used to compare accessibility across continents.

```{r}
dist_by_continent <- countries_final %>%
  st_drop_geometry() %>%
  filter(
    !is.na(avg_dist_airport_km),
    !is.na(continent),
    !continent %in% c("Antarctica", "Seven seas (open ocean)")
  )
```

We prepare the country-level distance data for analysis by continent.  
Countries with missing distance or continent information are removed so that the comparison across continents is based on valid observation

```{r}
ggplot(dist_by_continent, aes(x = avg_dist_airport_km)) +
  geom_histogram(bins = 20, fill = "steelblue", color = "white") +
  facet_wrap(~ continent, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "Distribution of average distance to airports by continent",
    x = "Average distance to nearest airport (km)",
    y = "Number of countries"
  )
```

We plot a histogram of the average distance to the nearest airport at the country level.  
The data are grouped by continent to compare differences in accessibility across regions.

